// Basic tokens
WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE    = _{ "\r\n" | "\n" }
COMMENT    = _{ "--" ~ (!NEWLINE ~ ANY)* }

// Literals
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
number     = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
string     = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
boolean    = @{ "true" | "false" }

// Operators
op_add   = { "+" }
op_sub   = { "-" }
op_mul   = { "*" }
op_div   = { "/" }
op_eq    = { "==" }
op_neq   = { "~=" }
op_lt    = { "<" }
op_gt    = { ">" }
op_le    = { "<=" }
op_ge    = { ">=" }
op_and   = { "and" }
op_or    = { "or" }
op_concat = { ".." }

operator = _{ op_eq | op_neq | op_le | op_ge | op_lt | op_gt | op_add | op_sub | op_mul | op_div | op_and | op_or | op_concat }

// Keywords
keyword = _{ "if" | "then" | "else" | "elseif" | "end" | "function" | "return" | "for" | "do" | "while" | "break" | "true" | "false" | "nil" | "import" | "from" | "require" | "not" }

// Grammar
program     = { SOI ~ statement* ~ EOI }
statement   = _{ (if_stmt | while_stmt | for_stmt | function_def | return_stmt | import_stmt | assignment | function_call | print_stmt) ~ NEWLINE* }
expression  = { term ~ (operator ~ term)* }
term        = _{ not_expr | index_access | table | number | string | boolean | nil | function_call | identifier | "(" ~ expression ~ ")" }

// Literals
nil = { "nil" }
not_expr = { "not" ~ (identifier | boolean | "(" ~ expression ~ ")") }

// Statements
import_stmt = { "import" ~ string }
assignment  = { identifier ~ "=" ~ expression }
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }
print_stmt  = { "print" ~ "(" ~ expression ~ ")" }

// Control flow
if_stmt = { "if" ~ expression ~ "then" ~ NEWLINE* ~ statement* ~ elseif_clause* ~ else_clause? ~ "end" }
elseif_clause = { "elseif" ~ expression ~ "then" ~ NEWLINE* ~ statement* }
else_clause = { "else" ~ NEWLINE* ~ statement* }

// Loops
while_stmt = { "while" ~ expression ~ "do" ~ NEWLINE* ~ statement* ~ "end" }
for_stmt = { "for" ~ identifier ~ "=" ~ expression ~ "," ~ expression ~ ("," ~ expression)? ~ "do" ~ NEWLINE* ~ statement* ~ "end" }

// Functions
function_def = { "function" ~ identifier ~ "(" ~ (identifier ~ ("," ~ identifier)*)? ~ ")" ~ NEWLINE* ~ statement* ~ "end" }
return_stmt = { "return" ~ expression? }

// Table and indexing
table = { "[" ~ (expression ~ ("," ~ expression)*)? ~ "]" }
index_access = { (identifier | table) ~ "[" ~ expression ~ "]" }