use crate::ast::AstNode;

/// Bytecode instructions for the Pickup VM.
#[derive(Debug, Clone)]
pub enum Instruction {
    PushNumber(f64),
    PushString(String),
    LoadVar(String),
    StoreVar(String),
    Add,
    Sub,
    Mul,
    Div,
    Concat,
    Print,
}

/// Compile an AST to bytecode instructions.
pub struct Compiler;

impl Compiler {
    pub fn compile(ast: &AstNode, verbose: bool) -> Vec<Instruction> {
        let mut code = Vec::new();
        Self::compile_node(ast, &mut code);
        if verbose {
            println!("Generated bytecode: {:?}", code);
        }
        code
    }

    fn compile_node(node: &AstNode, code: &mut Vec<Instruction>) {
        match node {
            AstNode::Program(stmts) => {
                for stmt in stmts {
                    Self::compile_node(stmt, code);
                }
            }
            AstNode::Number(n) => code.push(Instruction::PushNumber(*n)),
            AstNode::String(s) => code.push(Instruction::PushString(s.clone())),
            AstNode::Identifier(id) => code.push(Instruction::LoadVar(id.clone())),
            AstNode::Assignment(var, expr) => {
                // var is Identifier
                if let AstNode::Identifier(name) = &**var {
                    Self::compile_node(expr, code);
                    code.push(Instruction::StoreVar(name.clone()));
                }
            }
            AstNode::BinaryOp(left, op, right) => {
                Self::compile_node(left, code);
                Self::compile_node(right, code);
                match op.as_str() {
                    "+" => code.push(Instruction::Add),
                    "-" => code.push(Instruction::Sub),
                    "*" => code.push(Instruction::Mul),
                    "/" => code.push(Instruction::Div),
                    ".." => code.push(Instruction::Concat),
                    _ => {}
                }
            }
            AstNode::Print(expr) => {
                Self::compile_node(expr, code);
                code.push(Instruction::Print);
            }
            _ => {}
        }
    }
}

/// Value types for the Pickup VM.
#[derive(Debug, Clone)]
pub enum Value {
    Number(f64),
    String(String),
    Boolean(bool),
    Nil,
}

impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Number(n) => write!(f, "{}", n),
            Value::String(s) => write!(f, "{}", s),
            Value::Boolean(b) => write!(f, "{}", b),
            Value::Nil => write!(f, "nil"),
        }
    }
}

/// Simple bytecode interpreter.
pub struct Vm;

impl Vm {
    pub fn execute(code: &[Instruction], verbose: bool) {
        use std::collections::HashMap;
        let mut stack: Vec<String> = Vec::new();
        let mut vars: HashMap<String, String> = HashMap::new();

        if verbose {
            println!("\n--- VM Execution Log ---");
        }

        for (i, inst) in code.iter().enumerate() {
            if verbose {
                println!("Instruction {}: {:?}", i, inst);
            }

            match inst {
                Instruction::PushNumber(n) => {
                    stack.push(n.to_string());
                    if verbose {
                        println!("  Pushed number {}", n);
                    }
                }
                Instruction::PushString(s) => {
                    stack.push(s.clone());
                    if verbose {
                        println!("  Pushed string \"{}\"", s);
                    }
                }
                Instruction::LoadVar(name) => {
                    let val = vars.get(name).cloned().unwrap_or_default();
                    stack.push(val.clone());
                    if verbose {
                        println!("  Loaded var {} = \"{}\"", name, val);
                    }
                }
                Instruction::StoreVar(name) => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Stored \"{}\" in var {}", val, name);
                        }
                        vars.insert(name.clone(), val);
                    }
                }
                Instruction::Add => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let res = a.parse::<f64>().unwrap() + b.parse::<f64>().unwrap();
                    stack.push(res.to_string());
                    if verbose {
                        println!("  Add: {} + {} = {}", a, b, res);
                    }
                }
                Instruction::Sub => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let res = a.parse::<f64>().unwrap() - b.parse::<f64>().unwrap();
                    stack.push(res.to_string());
                    if verbose {
                        println!("  Sub: {} - {} = {}", a, b, res);
                    }
                }
                Instruction::Mul => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let res = a.parse::<f64>().unwrap() * b.parse::<f64>().unwrap();
                    stack.push(res.to_string());
                    if verbose {
                        println!("  Mul: {} * {} = {}", a, b, res);
                    }
                }
                Instruction::Div => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let res = a.parse::<f64>().unwrap() / b.parse::<f64>().unwrap();
                    stack.push(res.to_string());
                    if verbose {
                        println!("  Div: {} / {} = {}", a, b, res);
                    }
                }
                Instruction::Concat => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = format!("{}{}", a, b);
                    stack.push(result.clone());
                    if verbose {
                        println!("  Concat: \"{}\" .. \"{}\" = \"{}\"", a, b, result);
                    }
                }
                Instruction::Print => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Print: \"{}\"", val);
                            println!(">> {}", val);
                        } else {
                            println!("{}", val);
                        }
                    }
                }
            }

            if verbose {
                println!("  Stack: {:?}", stack);
                println!("  Vars: {:?}", vars);
                println!("");
            }
        }

        if verbose {
            println!("--- VM Execution Completed ---\n");
        }
    }
}
