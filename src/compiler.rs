use crate::ast::AstNode;
use std::collections::HashMap;

/// Bytecode instructions for the Pickup VM.
#[derive(Debug, Clone, PartialEq)]
pub enum Instruction {
    PushNumber(f64),
    PushString(String),
    PushBoolean(bool),
    PushNil,
    LoadVar(String),
    StoreVar(String),
    Add,
    Sub,
    Mul,
    Div,
    Concat,
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessEqual,
    GreaterEqual,
    And,
    Or,
    Not,
    Print,
    MakeTable(usize),  // Create a table with n elements from stack
    GetIndex,          // Get value at index from table
    LoadModule(String), // Load standard library module
    Jump(usize),       // Unconditional jump to instruction index
    JumpIfFalse(usize), // Jump to instruction index if top of stack is false
    Call(usize),       // Call function with n arguments
    Return,            // Return from function
    DefineFunction(String, usize, usize), // Define function (name, param_count, body_start)
    Pop,               // Pop value from stack
}

/// Compile an AST to bytecode instructions.
pub struct Compiler;

impl Compiler {
    pub fn compile(ast: &AstNode, verbose: bool) -> Vec<Instruction> {
        let mut code = Vec::new();
        Self::compile_node(ast, &mut code);
        if verbose {
            println!("Generated bytecode: {:?}", code);
        }
        code
    }

    fn compile_node(node: &AstNode, code: &mut Vec<Instruction>) {
        match node {
            AstNode::Program(stmts) => {
                for stmt in stmts {
                    Self::compile_node(stmt, code);
                }
            }
            AstNode::Number(n) => code.push(Instruction::PushNumber(*n)),
            AstNode::String(s) => code.push(Instruction::PushString(s.clone())),
            AstNode::Boolean(b) => code.push(Instruction::PushBoolean(*b)),
            AstNode::Nil => code.push(Instruction::PushNil),
            AstNode::Identifier(id) => code.push(Instruction::LoadVar(id.clone())),
            AstNode::Assignment(var, expr) => {
                // var is Identifier
                if let AstNode::Identifier(name) = &**var {
                    Self::compile_node(expr, code);
                    code.push(Instruction::StoreVar(name.clone()));
                }
            }
            AstNode::BinaryOp(left, op, right) => {
                Self::compile_node(left, code);
                Self::compile_node(right, code);
                match op.as_str() {
                    "+" => code.push(Instruction::Add),
                    "-" => code.push(Instruction::Sub),
                    "*" => code.push(Instruction::Mul),
                    "/" => code.push(Instruction::Div),
                    ".." => code.push(Instruction::Concat),
                    "==" => code.push(Instruction::Equal),
                    "~=" => code.push(Instruction::NotEqual),
                    "<" => code.push(Instruction::LessThan),
                    ">" => code.push(Instruction::GreaterThan),
                    "<=" => code.push(Instruction::LessEqual),
                    ">=" => code.push(Instruction::GreaterEqual),
                    "and" => code.push(Instruction::And),
                    "or" => code.push(Instruction::Or),
                    _ => {}
                }
            }
            AstNode::Not(expr) => {
                Self::compile_node(expr, code);
                code.push(Instruction::Not);
            }
            AstNode::Print(expr) => {
                Self::compile_node(expr, code);
                code.push(Instruction::Print);
            }
            AstNode::Table(elements) => {
                for elem in elements {
                    Self::compile_node(elem, code);
                }
                code.push(Instruction::MakeTable(elements.len()));
            }
            AstNode::Index(base, index) => {
                Self::compile_node(base, code);
                Self::compile_node(index, code);
                code.push(Instruction::GetIndex);
            }
            AstNode::Import(module) => {
                code.push(Instruction::LoadModule(module.clone()));
            }
            AstNode::If(condition, then_block, elseif_clauses, else_block) => {
                // Compile condition
                Self::compile_node(condition, code);
                
                // Reserve space for JumpIfFalse (will patch later)
                let jump_to_next = code.len();
                code.push(Instruction::JumpIfFalse(0));
                
                // Compile then block
                for stmt in then_block {
                    Self::compile_node(stmt, code);
                }
                
                // Reserve space for Jump to end (skip else blocks)
                let jump_to_end = code.len();
                code.push(Instruction::Jump(0));
                
                // Patch the JumpIfFalse to jump here (start of elseif/else)
                let next_block_start = code.len();
                code[jump_to_next] = Instruction::JumpIfFalse(next_block_start);
                
                let mut jumps_to_end = vec![jump_to_end];
                
                // Compile elseif clauses
                for (elseif_cond, elseif_block) in elseif_clauses {
                    Self::compile_node(elseif_cond, code);
                    let elseif_jump = code.len();
                    code.push(Instruction::JumpIfFalse(0));
                    
                    for stmt in elseif_block {
                        Self::compile_node(stmt, code);
                    }
                    
                    let elseif_end_jump = code.len();
                    code.push(Instruction::Jump(0));
                    jumps_to_end.push(elseif_end_jump);
                    
                    let next_elseif_start = code.len();
                    code[elseif_jump] = Instruction::JumpIfFalse(next_elseif_start);
                }
                
                // Compile else block
                if let Some(else_stmts) = else_block {
                    for stmt in else_stmts {
                        Self::compile_node(stmt, code);
                    }
                }
                
                // Patch all jumps to end
                let end_pos = code.len();
                for jump_pos in jumps_to_end {
                    code[jump_pos] = Instruction::Jump(end_pos);
                }
            }
            AstNode::While(condition, body) => {
                let loop_start = code.len();
                
                // Compile condition
                Self::compile_node(condition, code);
                
                // Jump past loop if condition is false
                let jump_to_end = code.len();
                code.push(Instruction::JumpIfFalse(0));
                
                // Compile body
                for stmt in body {
                    Self::compile_node(stmt, code);
                }
                
                // Jump back to start
                code.push(Instruction::Jump(loop_start));
                
                // Patch the JumpIfFalse
                let end_pos = code.len();
                code[jump_to_end] = Instruction::JumpIfFalse(end_pos);
            }
            AstNode::For(var, start, end, step, body) => {
                // Initialize loop variable
                Self::compile_node(start, code);
                code.push(Instruction::StoreVar(var.clone()));
                
                let loop_start = code.len();
                
                // Check condition: var <= end (or >= for negative step)
                code.push(Instruction::LoadVar(var.clone()));
                Self::compile_node(end, code);
                code.push(Instruction::LessEqual); // TODO: Handle negative steps
                
                let jump_to_end = code.len();
                code.push(Instruction::JumpIfFalse(0));
                
                // Compile body
                for stmt in body {
                    Self::compile_node(stmt, code);
                }
                
                // Increment loop variable
                code.push(Instruction::LoadVar(var.clone()));
                if let Some(step_expr) = step {
                    Self::compile_node(step_expr, code);
                } else {
                    code.push(Instruction::PushNumber(1.0));
                }
                code.push(Instruction::Add);
                code.push(Instruction::StoreVar(var.clone()));
                
                // Jump back to start
                code.push(Instruction::Jump(loop_start));
                
                // Patch the JumpIfFalse
                let end_pos = code.len();
                code[jump_to_end] = Instruction::JumpIfFalse(end_pos);
            }
            AstNode::FunctionDef(name, params, body) => {
                // Compile function body separately
                let mut func_code = Vec::new();
                for stmt in body {
                    Self::compile_node(stmt, &mut func_code);
                }
                func_code.push(Instruction::Return);
                
                // Store function as a value
                code.push(Instruction::DefineFunction(name.clone(), params.len(), func_code.len()));
                // Store the function instructions after the definition
                code.extend(func_code);
            }
            AstNode::Return(expr) => {
                if let Some(value) = expr {
                    Self::compile_node(value, code);
                } else {
                    code.push(Instruction::PushNil);
                }
                code.push(Instruction::Return);
            }
            AstNode::FunctionCall(name, args) => {
                // Push arguments onto stack
                for arg in args {
                    Self::compile_node(arg, code);
                }
                // For now, we'll handle function calls specially
                // This is a simplified version - real implementation would be more complex
                code.push(Instruction::Call(args.len()));
            }
        }
    }
}

/// Value types for the Pickup VM.
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Number(f64),
    String(String),
    Boolean(bool),
    Table(Vec<Value>),
    Function(Vec<String>, Vec<Instruction>), // Parameters and compiled body
    Module(HashMap<String, Value>),
    Nil,
}

impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Number(n) => write!(f, "{}", n),
            Value::String(s) => write!(f, "{}", s),
            Value::Boolean(b) => write!(f, "{}", b),
            Value::Table(elems) => {
                let items: Vec<String> = elems.iter().map(|v| v.to_string()).collect();
                write!(f, "[{}]", items.join(", "))
            }
            Value::Function(_, _) => write!(f, "<function>"),
            Value::Module(_) => write!(f, "<module>"),
            Value::Nil => write!(f, "nil"),
        }
    }
}

impl Value {
    /// Convert value to boolean for conditional evaluation
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Nil => false,
            Value::Boolean(b) => *b,
            Value::Number(n) => *n != 0.0,
            Value::String(s) => !s.is_empty(),
            _ => true,
        }
    }
}

// Helper to convert string representation to Value
fn string_to_value(s: &str) -> Value {
    if let Ok(n) = s.parse::<f64>() {
        Value::Number(n)
    } else if s == "true" {
        Value::Boolean(true)
    } else if s == "false" {
        Value::Boolean(false)
    } else if s == "nil" {
        Value::Nil
    } else {
        Value::String(s.to_string())
    }
}

/// Simple bytecode interpreter.
pub struct Vm;

impl Vm {
    pub fn execute(code: &[Instruction], verbose: bool) {
        let mut stack: Vec<Value> = Vec::new();
        let mut vars: HashMap<String, Value> = HashMap::new();
        let mut pc = 0; // Program counter
        
        // Initialize standard library
        let stdlib = crate::stdlib::create_stdlib();

        if verbose {
            println!("\n--- VM Execution Log ---");
        }

        while pc < code.len() {
            if verbose {
                println!("Instruction {}: {:?}", pc, code[pc]);
            }

            match &code[pc] {
                Instruction::PushNumber(n) => {
                    stack.push(Value::Number(*n));
                    if verbose {
                        println!("  Pushed number {}", n);
                    }
                    pc += 1;
                }
                Instruction::PushString(s) => {
                    stack.push(Value::String(s.clone()));
                    if verbose {
                        println!("  Pushed string \"{}\"", s);
                    }
                    pc += 1;
                }
                Instruction::PushBoolean(b) => {
                    stack.push(Value::Boolean(*b));
                    if verbose {
                        println!("  Pushed boolean {}", b);
                    }
                    pc += 1;
                }
                Instruction::PushNil => {
                    stack.push(Value::Nil);
                    if verbose {
                        println!("  Pushed nil");
                    }
                    pc += 1;
                }
                Instruction::LoadVar(name) => {
                    let val = vars.get(name).cloned().unwrap_or(Value::Nil);
                    stack.push(val.clone());
                    if verbose {
                        println!("  Loaded var {} = {:?}", name, val);
                    }
                    pc += 1;
                }
                Instruction::StoreVar(name) => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Stored {:?} in var {}", val, name);
                        }
                        vars.insert(name.clone(), val);
                    }
                    pc += 1;
                }
                Instruction::Add => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x + y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Add: {} + {} = {}", x, y, res);
                        }
                    }
                    pc += 1;
                }
                Instruction::Sub => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x - y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Sub: {} - {} = {}", x, y, res);
                        }
                    }
                    pc += 1;
                }
                Instruction::Mul => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x * y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Mul: {} * {} = {}", x, y, res);
                        }
                    }
                    pc += 1;
                }
                Instruction::Div => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x / y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Div: {} / {} = {}", x, y, res);
                        }
                    }
                    pc += 1;
                }
                Instruction::Concat => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = format!("{}{}", a, b);
                    stack.push(Value::String(result.clone()));
                    if verbose {
                        println!("  Concat: \"{}\" .. \"{}\" = \"{}\"", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::Equal => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = a == b;
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Equal: {:?} == {:?} = {}", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::NotEqual => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = a != b;
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  NotEqual: {:?} ~= {:?} = {}", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::LessThan => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        x < y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  LessThan result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::GreaterThan => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        x > y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  GreaterThan result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::LessEqual => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        x <= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  LessEqual result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::GreaterEqual => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        x >= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  GreaterEqual result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::And => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = a.is_truthy() && b.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  And: {} and {} = {}", a.is_truthy(), b.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Or => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = a.is_truthy() || b.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Or: {} or {} = {}", a.is_truthy(), b.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Not => {
                    let a = stack.pop().unwrap();
                    let result = !a.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Not: not {} = {}", a.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Jump(target) => {
                    if verbose {
                        println!("  Jump to {}", target);
                    }
                    pc = *target;
                }
                Instruction::JumpIfFalse(target) => {
                    let condition = stack.pop().unwrap();
                    if verbose {
                        println!("  JumpIfFalse: condition = {:?}", condition);
                    }
                    if !condition.is_truthy() {
                        if verbose {
                            println!("  Jumping to {}", target);
                        }
                        pc = *target;
                    } else {
                        pc += 1;
                    }
                }
                Instruction::MakeTable(size) => {
                    let mut elements = Vec::new();
                    for _ in 0..*size {
                        if let Some(val) = stack.pop() {
                            elements.push(val);
                        }
                    }
                    elements.reverse();
                    stack.push(Value::Table(elements));
                    if verbose {
                        println!("  Created table with {} elements", size);
                    }
                    pc += 1;
                }
                Instruction::GetIndex => {
                    let index = stack.pop().unwrap();
                    let table = stack.pop().unwrap();
                    
                    if let (Value::Table(elems), Value::Number(idx)) = (table, index) {
                        let i = idx as usize;
                        if i < elems.len() {
                            stack.push(elems[i].clone());
                            if verbose {
                                println!("  Got element at index {}", i);
                            }
                        } else {
                            stack.push(Value::Nil);
                            if verbose {
                                println!("  Index {} out of bounds", i);
                            }
                        }
                    }
                    pc += 1;
                }
                Instruction::LoadModule(name) => {
                    if let Some(module) = stdlib.get(name) {
                        vars.insert(name.clone(), module.clone());
                        if verbose {
                            println!("  Loaded module {}", name);
                        }
                    } else {
                        eprintln!("Module '{}' not found", name);
                    }
                    pc += 1;
                }
                Instruction::Print => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Print: {:?}", val);
                            println!(">> {}", val);
                        } else {
                            println!("{}", val);
                        }
                    }
                    pc += 1;
                }
                Instruction::DefineFunction(name, param_count, body_len) => {
                    // Extract function body from the code
                    let body_start = pc + 1;
                    let body_end = body_start + body_len;
                    let body = code[body_start..body_end].to_vec();
                    
                    // For now, we store empty params - full implementation would extract them
                    let func = Value::Function(vec![], body);
                    vars.insert(name.clone(), func);
                    
                    if verbose {
                        println!("  Defined function {} with {} params", name, param_count);
                    }
                    
                    // Skip over the function body
                    pc = body_end;
                }
                Instruction::Call(_arg_count) => {
                    // Simplified function call - would need full call stack in real implementation
                    if verbose {
                        println!("  Call instruction (simplified)");
                    }
                    pc += 1;
                }
                Instruction::Return => {
                    if verbose {
                        println!("  Return");
                    }
                    // Simplified - would pop call stack in real implementation
                    break;
                }
                Instruction::Pop => {
                    stack.pop();
                    if verbose {
                        println!("  Pop");
                    }
                    pc += 1;
                }
            }

            if verbose {
                println!("  Stack: {:?}", stack);
                println!("  Vars: {:?}", vars);
                println!("");
            }
        }

        if verbose {
            println!("--- VM Execution Completed ---\n");
        }
    }
}
