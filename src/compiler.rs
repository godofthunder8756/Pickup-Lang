use crate::ast::AstNode;
use std::collections::HashMap;

/// Bytecode instructions for the Pickup VM.
#[derive(Debug, Clone, PartialEq)]
pub enum Instruction {
    PushNumber(f64),
    PushString(String),
    PushBoolean(bool),
    PushNil,
    LoadVar(String),
    StoreVar(String),
    StoreLocal(String),
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    Concat,
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessEqual,
    GreaterEqual,
    And,
    Or,
    Not,
    Print,
    MakeTable(usize),       // Create a table with n elements from stack
    MakeDict(usize),        // Create a dictionary with n key-value pairs from stack
    GetIndex,               // Get value at index from table
    SetIndex,               // Set value at index in table
    GetMember(String),      // Get member by name from object/module
    SetMember(String),      // Set member by name in object/module
    LoadModule(String),     // Load standard library module
    Jump(usize),            // Unconditional jump to instruction index
    JumpIfFalse(usize),     // Jump to instruction index if top of stack is false
    Call(String, usize),    // Call function (name, arg_count)
    CallMethod(Vec<String>, usize), // Call method (member chain, arg_count)
    CallNative(String, String, usize), // Call native function (module, func, arg_count)
    Return,                 // Return from function
    DefineFunction(String, Vec<String>, usize), // Define function (name, params, body_len)
    DefineLambda(Vec<String>, usize), // Define anonymous function (params, body_len)
    Pop,                    // Pop value from stack
    Break,                  // Break from loop
    Continue,               // Continue loop
    SetupTry(usize),        // Setup try block with jump target on error
    PopTry,                 // Pop try handler
    Throw,                  // Throw an exception
    Dup,                    // Duplicate top of stack
}

/// Loop context for break/continue
#[derive(Debug, Clone)]
#[allow(dead_code)]
struct LoopContext {
    start: usize,
    continue_target: Option<usize>,  // For for loops, this points to increment section
    continue_jumps: Vec<usize>,      // Positions of continue jumps to patch
    break_jumps: Vec<usize>,
}

/// Compile an AST to bytecode instructions.
pub struct Compiler {
    loop_stack: Vec<LoopContext>,
}

impl Compiler {
    pub fn compile(ast: &AstNode, verbose: bool) -> Vec<Instruction> {
        let mut compiler = Compiler {
            loop_stack: Vec::new(),
        };
        let mut code = Vec::new();
        compiler.compile_node(ast, &mut code);
        if verbose {
            println!("Generated bytecode: {:?}", code);
        }
        code
    }

    fn compile_node(&mut self, node: &AstNode, code: &mut Vec<Instruction>) {
        match node {
            AstNode::Program(stmts) => {
                for stmt in stmts {
                    self.compile_node(stmt, code);
                }
            }
            AstNode::Number(n) => code.push(Instruction::PushNumber(*n)),
            AstNode::String(s) => code.push(Instruction::PushString(s.clone())),
            AstNode::Boolean(b) => code.push(Instruction::PushBoolean(*b)),
            AstNode::Nil => code.push(Instruction::PushNil),
            AstNode::Identifier(id) => code.push(Instruction::LoadVar(id.clone())),
            AstNode::Assignment(target, expr) => {
                self.compile_node(expr, code);
                match &**target {
                    AstNode::Identifier(name) => {
                        code.push(Instruction::StoreVar(name.clone()));
                    }
                    AstNode::MemberAccess(base, members) => {
                        self.compile_node(base, code);
                        // Navigate to the parent object
                        for i in 0..members.len() - 1 {
                            code.push(Instruction::GetMember(members[i].clone()));
                        }
                        // Set the final member
                        code.push(Instruction::SetMember(members.last().unwrap().clone()));
                    }
                    AstNode::Index(base, index) => {
                        self.compile_node(base, code);
                        self.compile_node(index, code);
                        code.push(Instruction::SetIndex);
                    }
                    _ => {}
                }
            }
            AstNode::LocalAssignment(name, expr) => {
                self.compile_node(expr, code);
                code.push(Instruction::StoreLocal(name.clone()));
            }
            AstNode::BinaryOp(left, op, right) => {
                self.compile_node(left, code);
                self.compile_node(right, code);
                match op.as_str() {
                    "+" => code.push(Instruction::Add),
                    "-" => code.push(Instruction::Sub),
                    "*" => code.push(Instruction::Mul),
                    "/" => code.push(Instruction::Div),
                    "%" => code.push(Instruction::Mod),
                    ".." => code.push(Instruction::Concat),
                    "==" => code.push(Instruction::Equal),
                    "~=" => code.push(Instruction::NotEqual),
                    "<" => code.push(Instruction::LessThan),
                    ">" => code.push(Instruction::GreaterThan),
                    "<=" => code.push(Instruction::LessEqual),
                    ">=" => code.push(Instruction::GreaterEqual),
                    "and" => code.push(Instruction::And),
                    "or" => code.push(Instruction::Or),
                    _ => {}
                }
            }
            AstNode::Not(expr) => {
                self.compile_node(expr, code);
                code.push(Instruction::Not);
            }
            AstNode::Print(expr) => {
                self.compile_node(expr, code);
                code.push(Instruction::Print);
            }
            AstNode::Table(elements) => {
                for elem in elements {
                    self.compile_node(elem, code);
                }
                code.push(Instruction::MakeTable(elements.len()));
            }
            AstNode::Dictionary(entries) => {
                for (key, value) in entries {
                    code.push(Instruction::PushString(key.clone()));
                    self.compile_node(value, code);
                }
                code.push(Instruction::MakeDict(entries.len()));
            }
            AstNode::Index(base, index) => {
                self.compile_node(base, code);
                self.compile_node(index, code);
                code.push(Instruction::GetIndex);
            }
            AstNode::MemberAccess(base, members) => {
                self.compile_node(base, code);
                for member in members {
                    code.push(Instruction::GetMember(member.clone()));
                }
            }
            AstNode::MethodCall(base, members, args) => {
                // Push arguments first
                for arg in args {
                    self.compile_node(arg, code);
                }
                // Push base object
                self.compile_node(base, code);
                // Call method
                code.push(Instruction::CallMethod(members.clone(), args.len()));
            }
            AstNode::Import(module) => {
                code.push(Instruction::LoadModule(module.clone()));
            }
            AstNode::If(condition, then_block, elseif_clauses, else_block) => {
                // Compile condition
                self.compile_node(condition, code);

                // Reserve space for JumpIfFalse (will patch later)
                let jump_to_next = code.len();
                code.push(Instruction::JumpIfFalse(0));

                // Compile then block
                for stmt in then_block {
                    self.compile_node(stmt, code);
                }

                // Reserve space for Jump to end (skip else blocks)
                let jump_to_end = code.len();
                code.push(Instruction::Jump(0));

                // Patch the JumpIfFalse to jump here (start of elseif/else)
                let next_block_start = code.len();
                code[jump_to_next] = Instruction::JumpIfFalse(next_block_start);

                let mut jumps_to_end = vec![jump_to_end];

                // Compile elseif clauses
                for (elseif_cond, elseif_block) in elseif_clauses {
                    self.compile_node(elseif_cond, code);
                    let elseif_jump = code.len();
                    code.push(Instruction::JumpIfFalse(0));

                    for stmt in elseif_block {
                        self.compile_node(stmt, code);
                    }

                    let elseif_end_jump = code.len();
                    code.push(Instruction::Jump(0));
                    jumps_to_end.push(elseif_end_jump);

                    let next_elseif_start = code.len();
                    code[elseif_jump] = Instruction::JumpIfFalse(next_elseif_start);
                }

                // Compile else block
                if let Some(else_stmts) = else_block {
                    for stmt in else_stmts {
                        self.compile_node(stmt, code);
                    }
                }

                // Patch all jumps to end
                let end_pos = code.len();
                for jump_pos in jumps_to_end {
                    code[jump_pos] = Instruction::Jump(end_pos);
                }
            }
            AstNode::While(condition, body) => {
                let loop_start = code.len();

                // Push loop context - for while loops, continue jumps to loop_start
                self.loop_stack.push(LoopContext {
                    start: loop_start,
                    continue_target: Some(loop_start),  // Continue jumps to condition check
                    continue_jumps: Vec::new(),
                    break_jumps: Vec::new(),
                });

                // Compile condition
                self.compile_node(condition, code);

                // Jump past loop if condition is false
                let jump_to_end = code.len();
                code.push(Instruction::JumpIfFalse(0));

                // Compile body
                for stmt in body {
                    self.compile_node(stmt, code);
                }

                // Jump back to start
                code.push(Instruction::Jump(loop_start));

                // Patch the JumpIfFalse
                let end_pos = code.len();
                code[jump_to_end] = Instruction::JumpIfFalse(end_pos);

                // Pop loop context and patch break/continue jumps
                if let Some(loop_ctx) = self.loop_stack.pop() {
                    for break_jump in loop_ctx.break_jumps {
                        code[break_jump] = Instruction::Jump(end_pos);
                    }
                    // For while loops, continue was already resolved with continue_target
                    for continue_jump in loop_ctx.continue_jumps {
                        code[continue_jump] = Instruction::Jump(loop_start);
                    }
                }
            }
            AstNode::For(var, start, end, step, body) => {
                // Initialize loop variable
                self.compile_node(start, code);
                code.push(Instruction::StoreVar(var.clone()));

                let loop_start = code.len();

                // Push loop context - continue_target will be set after body compilation
                self.loop_stack.push(LoopContext {
                    start: loop_start,
                    continue_target: None,  // Will be patched to increment section
                    continue_jumps: Vec::new(),
                    break_jumps: Vec::new(),
                });

                // Check condition: var <= end (or >= for negative step)
                code.push(Instruction::LoadVar(var.clone()));
                self.compile_node(end, code);
                code.push(Instruction::LessEqual);

                let jump_to_end = code.len();
                code.push(Instruction::JumpIfFalse(0));

                // Compile body
                for stmt in body {
                    self.compile_node(stmt, code);
                }

                // Mark increment section start for continue statements
                let increment_start = code.len();

                // Increment loop variable
                code.push(Instruction::LoadVar(var.clone()));
                if let Some(step_expr) = step {
                    self.compile_node(step_expr, code);
                } else {
                    code.push(Instruction::PushNumber(1.0));
                }
                code.push(Instruction::Add);
                code.push(Instruction::StoreVar(var.clone()));

                // Jump back to start
                code.push(Instruction::Jump(loop_start));

                // Patch the JumpIfFalse
                let end_pos = code.len();
                code[jump_to_end] = Instruction::JumpIfFalse(end_pos);

                // Pop loop context and patch break/continue jumps
                if let Some(loop_ctx) = self.loop_stack.pop() {
                    for break_jump in loop_ctx.break_jumps {
                        code[break_jump] = Instruction::Jump(end_pos);
                    }
                    // For for loops, continue jumps to increment section
                    for continue_jump in loop_ctx.continue_jumps {
                        code[continue_jump] = Instruction::Jump(increment_start);
                    }
                }
            }
            AstNode::Break => {
                // Add a jump instruction and record it for patching later
                let jump_pos = code.len();
                code.push(Instruction::Jump(0)); // Placeholder, will be patched
                if let Some(loop_ctx) = self.loop_stack.last_mut() {
                    loop_ctx.break_jumps.push(jump_pos);
                }
            }
            AstNode::Continue => {
                // Add a jump instruction and record it for patching later
                let jump_pos = code.len();
                code.push(Instruction::Jump(0)); // Placeholder, will be patched
                if let Some(loop_ctx) = self.loop_stack.last_mut() {
                    loop_ctx.continue_jumps.push(jump_pos);
                }
            }
            AstNode::FunctionDef(name, params, body) => {
                // Compile function body separately
                let mut func_code = Vec::new();
                let mut func_compiler = Compiler {
                    loop_stack: Vec::new(),
                };
                for stmt in body {
                    func_compiler.compile_node(stmt, &mut func_code);
                }
                // Add implicit return nil if no explicit return
                func_code.push(Instruction::PushNil);
                func_code.push(Instruction::Return);

                // Define the function with parameters
                code.push(Instruction::DefineFunction(name.clone(), params.clone(), func_code.len()));
                // Store the function instructions after the definition
                code.extend(func_code);
            }
            AstNode::Lambda(params, body) => {
                // Compile lambda body separately
                let mut lambda_code = Vec::new();
                let mut lambda_compiler = Compiler {
                    loop_stack: Vec::new(),
                };
                for stmt in body {
                    lambda_compiler.compile_node(stmt, &mut lambda_code);
                }
                // Add implicit return nil if no explicit return
                lambda_code.push(Instruction::PushNil);
                lambda_code.push(Instruction::Return);

                // Define the lambda
                code.push(Instruction::DefineLambda(params.clone(), lambda_code.len()));
                // Store the lambda instructions after the definition
                code.extend(lambda_code);
            }
            AstNode::Return(expr) => {
                if let Some(value) = expr {
                    self.compile_node(value, code);
                } else {
                    code.push(Instruction::PushNil);
                }
                code.push(Instruction::Return);
            }
            AstNode::FunctionCall(name, args) => {
                // Push arguments onto stack
                for arg in args {
                    self.compile_node(arg, code);
                }
                // Call the function by name
                code.push(Instruction::Call(name.clone(), args.len()));
            }
            AstNode::TryCatch(try_body, catch_var, catch_body) => {
                // Setup try with jump to catch
                let setup_try_pos = code.len();
                code.push(Instruction::SetupTry(0)); // Placeholder

                // Compile try block
                for stmt in try_body {
                    self.compile_node(stmt, code);
                }

                // Pop try handler after successful execution
                code.push(Instruction::PopTry);

                // Jump past catch block
                let jump_past_catch = code.len();
                code.push(Instruction::Jump(0)); // Placeholder

                // Patch SetupTry to point to catch block
                let catch_start = code.len();
                code[setup_try_pos] = Instruction::SetupTry(catch_start);

                // Store error in catch variable if provided
                if let Some(var) = catch_var {
                    code.push(Instruction::StoreVar(var.clone()));
                } else {
                    code.push(Instruction::Pop); // Discard error if no variable
                }

                // Compile catch block
                for stmt in catch_body {
                    self.compile_node(stmt, code);
                }

                // Patch jump past catch
                let after_catch = code.len();
                code[jump_past_catch] = Instruction::Jump(after_catch);
            }
            AstNode::Throw(expr) => {
                self.compile_node(expr, code);
                code.push(Instruction::Throw);
            }
        }
    }
}

/// Value types for the Pickup VM.
#[derive(Debug, Clone)]
pub enum Value {
    Number(f64),
    String(String),
    Boolean(bool),
    Table(Vec<Value>),
    Dictionary(HashMap<String, Value>),
    Function(Vec<String>, Vec<Instruction>), // Parameters and compiled body
    NativeFunction(String, String), // Module name, function name
    Module(HashMap<String, Value>),
    Nil,
}

impl PartialEq for Value {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Value::Number(a), Value::Number(b)) => a == b,
            (Value::String(a), Value::String(b)) => a == b,
            (Value::Boolean(a), Value::Boolean(b)) => a == b,
            (Value::Nil, Value::Nil) => true,
            (Value::Table(a), Value::Table(b)) => a == b,
            (Value::Dictionary(a), Value::Dictionary(b)) => a == b,
            _ => false,
        }
    }
}

impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Number(n) => {
                if n.fract() == 0.0 {
                    write!(f, "{}", *n as i64)
                } else {
                    write!(f, "{}", n)
                }
            }
            Value::String(s) => write!(f, "{}", s),
            Value::Boolean(b) => write!(f, "{}", b),
            Value::Table(elems) => {
                let items: Vec<String> = elems.iter().map(|v| v.to_string()).collect();
                write!(f, "[{}]", items.join(", "))
            }
            Value::Dictionary(map) => {
                let items: Vec<String> = map.iter()
                    .map(|(k, v)| format!("{} = {}", k, v))
                    .collect();
                write!(f, "{{{}}}", items.join(", "))
            }
            Value::Function(params, _) => write!(f, "<function({})>", params.join(", ")),
            Value::NativeFunction(module, name) => write!(f, "<native:{}.{}>", module, name),
            Value::Module(members) => {
                let keys: Vec<&String> = members.keys().collect();
                write!(f, "<module: {}>", keys.iter().map(|s| s.as_str()).collect::<Vec<_>>().join(", "))
            }
            Value::Nil => write!(f, "nil"),
        }
    }
}

impl Value {
    /// Convert value to boolean for conditional evaluation
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Nil => false,
            Value::Boolean(b) => *b,
            Value::Number(n) => *n != 0.0,
            Value::String(s) => !s.is_empty(),
            _ => true,
        }
    }
}

/// Runtime error type
#[derive(Debug, Clone)]
pub struct RuntimeError {
    pub message: String,
}

impl RuntimeError {
    pub fn new(message: impl Into<String>) -> Self {
        RuntimeError { message: message.into() }
    }
}

impl std::fmt::Display for RuntimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RuntimeError: {}", self.message)
    }
}

/// Try handler for exception handling
#[derive(Debug, Clone)]
struct TryHandler {
    catch_pc: usize,
    stack_depth: usize,
}

/// Call frame for function execution
#[derive(Debug, Clone)]
struct CallFrame {
    return_pc: usize,
    local_vars: HashMap<String, Value>,
}

/// Simple bytecode interpreter.
pub struct Vm;

impl Vm {
    pub fn execute(code: &[Instruction], verbose: bool) {
        let mut stack: Vec<Value> = Vec::new();
        let mut vars: HashMap<String, Value> = HashMap::new();
        let mut call_stack: Vec<CallFrame> = Vec::new();
        let mut try_handlers: Vec<TryHandler> = Vec::new();
        let mut pc = 0; // Program counter

        // Initialize standard library
        let stdlib = crate::stdlib::create_stdlib();

        if verbose {
            println!("\n--- VM Execution Log ---");
        }

        while pc < code.len() {
            if verbose {
                println!("Instruction {}: {:?}", pc, code[pc]);
            }

            match &code[pc] {
                Instruction::PushNumber(n) => {
                    stack.push(Value::Number(*n));
                    if verbose {
                        println!("  Pushed number {}", n);
                    }
                    pc += 1;
                }
                Instruction::PushString(s) => {
                    stack.push(Value::String(s.clone()));
                    if verbose {
                        println!("  Pushed string \"{}\"", s);
                    }
                    pc += 1;
                }
                Instruction::PushBoolean(b) => {
                    stack.push(Value::Boolean(*b));
                    if verbose {
                        println!("  Pushed boolean {}", b);
                    }
                    pc += 1;
                }
                Instruction::PushNil => {
                    stack.push(Value::Nil);
                    if verbose {
                        println!("  Pushed nil");
                    }
                    pc += 1;
                }
                Instruction::LoadVar(name) => {
                    let val = vars.get(name).cloned().unwrap_or(Value::Nil);
                    stack.push(val.clone());
                    if verbose {
                        println!("  Loaded var {} = {:?}", name, val);
                    }
                    pc += 1;
                }
                Instruction::StoreVar(name) => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Stored {:?} in var {}", val, name);
                        }
                        vars.insert(name.clone(), val);
                    }
                    pc += 1;
                }
                Instruction::StoreLocal(name) => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Stored {:?} in local var {}", val, name);
                        }
                        vars.insert(name.clone(), val);
                    }
                    pc += 1;
                }
                Instruction::Add => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    match (&a, &b) {
                        (Value::Number(x), Value::Number(y)) => {
                            let res = x + y;
                            stack.push(Value::Number(res));
                            if verbose {
                                println!("  Add: {} + {} = {}", x, y, res);
                            }
                        }
                        _ => {
                            stack.push(Value::Nil);
                            if verbose {
                                println!("  Add: type error");
                            }
                        }
                    }
                    pc += 1;
                }
                Instruction::Sub => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x - y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Sub: {} - {} = {}", x, y, res);
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Mul => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x * y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Mul: {} * {} = {}", x, y, res);
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Div => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        if y == 0.0 {
                            Self::handle_error(&mut stack, &mut try_handlers, &mut pc, "Division by zero");
                            continue;
                        }
                        let res = x / y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Div: {} / {} = {}", x, y, res);
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Mod => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        if y == 0.0 {
                            Self::handle_error(&mut stack, &mut try_handlers, &mut pc, "Modulo by zero");
                            continue;
                        }
                        let res = x % y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Mod: {} % {} = {}", x, y, res);
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Concat => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = format!("{}{}", a, b);
                    stack.push(Value::String(result.clone()));
                    if verbose {
                        println!("  Concat: \"{}\" .. \"{}\" = \"{}\"", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::Equal => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = a == b;
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Equal: {:?} == {:?} = {}", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::NotEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = a != b;
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  NotEqual: {:?} ~= {:?} = {}", a, b, result);
                    }
                    pc += 1;
                }
                Instruction::LessThan => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x < y
                    } else if let (Value::String(x), Value::String(y)) = (&a, &b) {
                        x < y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  LessThan result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::GreaterThan => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x > y
                    } else if let (Value::String(x), Value::String(y)) = (&a, &b) {
                        x > y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  GreaterThan result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::LessEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x <= y
                    } else if let (Value::String(x), Value::String(y)) = (&a, &b) {
                        x <= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  LessEqual result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::GreaterEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x >= y
                    } else if let (Value::String(x), Value::String(y)) = (&a, &b) {
                        x >= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  GreaterEqual result: {}", result);
                    }
                    pc += 1;
                }
                Instruction::And => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = a.is_truthy() && b.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  And: {} and {} = {}", a.is_truthy(), b.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Or => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = a.is_truthy() || b.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Or: {} or {} = {}", a.is_truthy(), b.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Not => {
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = !a.is_truthy();
                    stack.push(Value::Boolean(result));
                    if verbose {
                        println!("  Not: not {} = {}", a.is_truthy(), result);
                    }
                    pc += 1;
                }
                Instruction::Jump(target) => {
                    if verbose {
                        println!("  Jump to {}", target);
                    }
                    pc = *target;
                }
                Instruction::JumpIfFalse(target) => {
                    let condition = stack.pop().unwrap_or(Value::Nil);
                    if verbose {
                        println!("  JumpIfFalse: condition = {:?}", condition);
                    }
                    if !condition.is_truthy() {
                        if verbose {
                            println!("  Jumping to {}", target);
                        }
                        pc = *target;
                    } else {
                        pc += 1;
                    }
                }
                Instruction::MakeTable(size) => {
                    let mut elements = Vec::new();
                    for _ in 0..*size {
                        if let Some(val) = stack.pop() {
                            elements.push(val);
                        }
                    }
                    elements.reverse();
                    stack.push(Value::Table(elements));
                    if verbose {
                        println!("  Created table with {} elements", size);
                    }
                    pc += 1;
                }
                Instruction::MakeDict(size) => {
                    let mut entries = HashMap::new();
                    for _ in 0..*size {
                        let value = stack.pop().unwrap_or(Value::Nil);
                        let key = match stack.pop().unwrap_or(Value::Nil) {
                            Value::String(s) => s,
                            v => v.to_string(),
                        };
                        entries.insert(key, value);
                    }
                    stack.push(Value::Dictionary(entries));
                    if verbose {
                        println!("  Created dictionary with {} entries", size);
                    }
                    pc += 1;
                }
                Instruction::GetIndex => {
                    let index = stack.pop().unwrap_or(Value::Nil);
                    let container = stack.pop().unwrap_or(Value::Nil);

                    match (&container, &index) {
                        (Value::Table(elems), Value::Number(idx)) => {
                            let i = *idx as usize;
                            if i < elems.len() {
                                stack.push(elems[i].clone());
                                if verbose {
                                    println!("  Got element at index {}", i);
                                }
                            } else {
                                stack.push(Value::Nil);
                                if verbose {
                                    println!("  Index {} out of bounds", i);
                                }
                            }
                        }
                        (Value::Dictionary(map), Value::String(key)) => {
                            let val = map.get(key).cloned().unwrap_or(Value::Nil);
                            stack.push(val);
                            if verbose {
                                println!("  Got dictionary value for key '{}'", key);
                            }
                        }
                        (Value::String(s), Value::Number(idx)) => {
                            let i = *idx as usize;
                            if i < s.len() {
                                stack.push(Value::String(s.chars().nth(i).unwrap().to_string()));
                            } else {
                                stack.push(Value::Nil);
                            }
                        }
                        _ => {
                            stack.push(Value::Nil);
                        }
                    }
                    pc += 1;
                }
                Instruction::SetIndex => {
                    let value = stack.pop().unwrap_or(Value::Nil);
                    let index = stack.pop().unwrap_or(Value::Nil);
                    let container = stack.pop().unwrap_or(Value::Nil);

                    // Note: This is a simplified version; proper implementation would modify in place
                    match (container, index) {
                        (Value::Table(mut elems), Value::Number(idx)) => {
                            let i = idx as usize;
                            if i < elems.len() {
                                elems[i] = value;
                            }
                            // Would need to update the variable reference here
                        }
                        (Value::Dictionary(mut map), Value::String(key)) => {
                            map.insert(key, value);
                            // Would need to update the variable reference here
                        }
                        _ => {}
                    }
                    pc += 1;
                }
                Instruction::GetMember(name) => {
                    let obj = stack.pop().unwrap_or(Value::Nil);
                    match obj {
                        Value::Module(members) => {
                            let val = members.get(name).cloned().unwrap_or(Value::Nil);
                            stack.push(val);
                            if verbose {
                                println!("  Got module member '{}'", name);
                            }
                        }
                        Value::Dictionary(map) => {
                            let val = map.get(name).cloned().unwrap_or(Value::Nil);
                            stack.push(val);
                            if verbose {
                                println!("  Got dictionary member '{}'", name);
                            }
                        }
                        _ => {
                            stack.push(Value::Nil);
                            if verbose {
                                println!("  Cannot get member '{}' from {:?}", name, obj);
                            }
                        }
                    }
                    pc += 1;
                }
                Instruction::SetMember(name) => {
                    let value = stack.pop().unwrap_or(Value::Nil);
                    let obj = stack.pop().unwrap_or(Value::Nil);
                    // Note: Would need variable reference to modify in place
                    if verbose {
                        println!("  Set member '{}' = {:?}", name, value);
                    }
                    pc += 1;
                }
                Instruction::LoadModule(name) => {
                    if let Some(module) = stdlib.get(name) {
                        vars.insert(name.clone(), module.clone());
                        if verbose {
                            println!("  Loaded module {}", name);
                        }
                    } else {
                        eprintln!("Module '{}' not found", name);
                    }
                    pc += 1;
                }
                Instruction::Print => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Print: {:?}", val);
                            println!(">> {}", val);
                        } else {
                            println!("{}", val);
                        }
                    }
                    pc += 1;
                }
                Instruction::DefineFunction(name, params, body_len) => {
                    // Extract function body from the code
                    let body_start = pc + 1;
                    let body_end = body_start + body_len;
                    let body = code[body_start..body_end].to_vec();

                    // Store function with parameters
                    let func = Value::Function(params.clone(), body);
                    vars.insert(name.clone(), func);

                    if verbose {
                        println!("  Defined function {} with {} params: {:?}", name, params.len(), params);
                    }

                    // Skip over the function body
                    pc = body_end;
                }
                Instruction::DefineLambda(params, body_len) => {
                    // Extract lambda body from the code
                    let body_start = pc + 1;
                    let body_end = body_start + body_len;
                    let body = code[body_start..body_end].to_vec();

                    // Push lambda as a value on the stack
                    let func = Value::Function(params.clone(), body);
                    stack.push(func);

                    if verbose {
                        println!("  Created lambda with {} params", params.len());
                    }

                    // Skip over the lambda body
                    pc = body_end;
                }
                Instruction::Call(func_name, arg_count) => {
                    // Get the function from variables
                    if let Some(func_val) = vars.get(func_name).cloned() {
                        match func_val {
                            Value::Function(params, body) => {
                                if params.len() != *arg_count {
                                    eprintln!("Error: Function {} expects {} arguments, got {}", func_name, params.len(), arg_count);
                                    pc += 1;
                                    continue;
                                }

                                // Pop arguments from stack in reverse order
                                let mut args = Vec::new();
                                for _ in 0..*arg_count {
                                    if let Some(arg) = stack.pop() {
                                        args.push(arg);
                                    }
                                }
                                args.reverse();

                                // Create new call frame
                                let mut local_vars = HashMap::new();

                                // Bind parameters to arguments
                                for (i, param_name) in params.iter().enumerate() {
                                    if i < args.len() {
                                        local_vars.insert(param_name.clone(), args[i].clone());
                                    }
                                }

                                // Save current state
                                call_stack.push(CallFrame {
                                    return_pc: pc + 1,
                                    local_vars: vars.clone(),
                                });

                                // Set up function scope - merge local vars with parameters
                                for (k, v) in local_vars.iter() {
                                    vars.insert(k.clone(), v.clone());
                                }

                                if verbose {
                                    println!("  Calling function {} with {} args", func_name, arg_count);
                                    println!("  Parameters bound: {:?}", local_vars);
                                }

                                // Execute function body - create new code context
                                Self::execute_function(&body, &mut stack, &mut vars, verbose);

                                // Restore state
                                if let Some(frame) = call_stack.pop() {
                                    pc = frame.return_pc;
                                    vars = frame.local_vars;
                                } else {
                                    pc += 1;
                                }
                            }
                            _ => {
                                eprintln!("Error: {} is not a function", func_name);
                                pc += 1;
                            }
                        }
                    } else {
                        eprintln!("Error: Function {} not found", func_name);
                        pc += 1;
                    }
                }
                Instruction::CallMethod(members, arg_count) => {
                    // Pop base object
                    let base = stack.pop().unwrap_or(Value::Nil);

                    // Pop arguments
                    let mut args = Vec::new();
                    for _ in 0..*arg_count {
                        if let Some(arg) = stack.pop() {
                            args.push(arg);
                        }
                    }
                    args.reverse();

                    // Navigate to method
                    let mut current = base.clone();
                    let method_name = members.last().cloned().unwrap_or_default();

                    // Navigate through intermediate members
                    for i in 0..members.len() - 1 {
                        current = match current {
                            Value::Module(ref map) => map.get(&members[i]).cloned().unwrap_or(Value::Nil),
                            Value::Dictionary(ref map) => map.get(&members[i]).cloned().unwrap_or(Value::Nil),
                            _ => Value::Nil,
                        };
                    }

                    // Get the method/function
                    let method = match &current {
                        Value::Module(map) => map.get(&method_name).cloned(),
                        Value::Dictionary(map) => map.get(&method_name).cloned(),
                        _ => None,
                    };

                    // Execute method
                    if let Some(method_val) = method {
                        match method_val {
                            Value::NativeFunction(module, func) => {
                                let result = crate::stdlib::call_native(&module, &func, args, verbose);
                                stack.push(result);
                            }
                            Value::Function(params, body) => {
                                // Bind parameters
                                let mut func_vars = vars.clone();
                                for (i, param) in params.iter().enumerate() {
                                    if i < args.len() {
                                        func_vars.insert(param.clone(), args[i].clone());
                                    }
                                }
                                // Execute function
                                Self::execute_function(&body, &mut stack, &mut func_vars, verbose);
                            }
                            _ => {
                                stack.push(Value::Nil);
                            }
                        }
                    } else {
                        // Try calling as native based on module structure
                        if let Value::Module(_) = &base {
                            if let Some(module_name) = Self::get_module_name(&base, &vars) {
                                let result = crate::stdlib::call_native(&module_name, &method_name, args, verbose);
                                stack.push(result);
                            } else {
                                stack.push(Value::Nil);
                            }
                        } else {
                            stack.push(Value::Nil);
                        }
                    }

                    pc += 1;
                }
                Instruction::CallNative(module, func, arg_count) => {
                    let mut args = Vec::new();
                    for _ in 0..*arg_count {
                        if let Some(arg) = stack.pop() {
                            args.push(arg);
                        }
                    }
                    args.reverse();

                    let result = crate::stdlib::call_native(module, func, args, verbose);
                    stack.push(result);
                    pc += 1;
                }
                Instruction::Return => {
                    if verbose {
                        println!("  Return from function");
                    }
                    // For function return, the calling context will handle it
                    // This ends the function execution
                    break;
                }
                Instruction::SetupTry(catch_pc) => {
                    try_handlers.push(TryHandler {
                        catch_pc: *catch_pc,
                        stack_depth: stack.len(),
                    });
                    if verbose {
                        println!("  Setup try handler, jump to {} on error", catch_pc);
                    }
                    pc += 1;
                }
                Instruction::PopTry => {
                    try_handlers.pop();
                    if verbose {
                        println!("  Popped try handler");
                    }
                    pc += 1;
                }
                Instruction::Throw => {
                    let error = stack.pop().unwrap_or(Value::String("Unknown error".to_string()));
                    let error_msg = error.to_string();

                    if let Some(handler) = try_handlers.pop() {
                        // Restore stack to handler depth
                        while stack.len() > handler.stack_depth {
                            stack.pop();
                        }
                        // Push error value
                        stack.push(Value::String(error_msg));
                        pc = handler.catch_pc;
                        if verbose {
                            println!("  Caught error, jumping to {}", handler.catch_pc);
                        }
                    } else {
                        eprintln!("Uncaught error: {}", error_msg);
                        break;
                    }
                }
                Instruction::Dup => {
                    if let Some(val) = stack.last().cloned() {
                        stack.push(val);
                    }
                    pc += 1;
                }
                Instruction::Pop => {
                    stack.pop();
                    if verbose {
                        println!("  Pop");
                    }
                    pc += 1;
                }
                Instruction::Break => {
                    // Break is compiled as a Jump, so this shouldn't be reached
                    if verbose {
                        println!("  Break (unexpected)");
                    }
                    pc += 1;
                }
                Instruction::Continue => {
                    // Continue is compiled as a Jump, so this shouldn't be reached
                    if verbose {
                        println!("  Continue (unexpected)");
                    }
                    pc += 1;
                }
            }

            if verbose {
                println!("  Stack: {:?}", stack);
                println!("  Vars: {:?}", vars);
                println!("");
            }
        }

        if verbose {
            println!("--- VM Execution Completed ---\n");
        }
    }

    /// Try to get the module name from a value
    fn get_module_name(val: &Value, vars: &HashMap<String, Value>) -> Option<String> {
        for (name, v) in vars {
            if std::ptr::eq(val, v) {
                return Some(name.clone());
            }
        }
        // Check against known module names
        match val {
            Value::Module(_) => {
                for (name, v) in vars {
                    if let Value::Module(_) = v {
                        if format!("{:?}", val) == format!("{:?}", v) {
                            return Some(name.clone());
                        }
                    }
                }
            }
            _ => {}
        }
        None
    }

    /// Handle runtime error
    fn handle_error(stack: &mut Vec<Value>, try_handlers: &mut Vec<TryHandler>, pc: &mut usize, message: &str) {
        if let Some(handler) = try_handlers.pop() {
            while stack.len() > handler.stack_depth {
                stack.pop();
            }
            stack.push(Value::String(message.to_string()));
            *pc = handler.catch_pc;
        } else {
            eprintln!("Runtime error: {}", message);
            *pc = usize::MAX; // Stop execution
        }
    }

    /// Execute a function body (used for function calls)
    fn execute_function(code: &[Instruction], stack: &mut Vec<Value>, vars: &mut HashMap<String, Value>, verbose: bool) {
        let mut pc = 0;
        let mut try_handlers: Vec<TryHandler> = Vec::new();

        while pc < code.len() {
            if verbose {
                println!("  [Function] Instruction {}: {:?}", pc, code[pc]);
            }

            match &code[pc] {
                Instruction::PushNumber(n) => {
                    stack.push(Value::Number(*n));
                    pc += 1;
                }
                Instruction::PushString(s) => {
                    stack.push(Value::String(s.clone()));
                    pc += 1;
                }
                Instruction::PushBoolean(b) => {
                    stack.push(Value::Boolean(*b));
                    pc += 1;
                }
                Instruction::PushNil => {
                    stack.push(Value::Nil);
                    pc += 1;
                }
                Instruction::LoadVar(name) => {
                    let val = vars.get(name).cloned().unwrap_or(Value::Nil);
                    stack.push(val);
                    pc += 1;
                }
                Instruction::StoreVar(name) => {
                    if let Some(val) = stack.pop() {
                        vars.insert(name.clone(), val);
                    }
                    pc += 1;
                }
                Instruction::StoreLocal(name) => {
                    if let Some(val) = stack.pop() {
                        vars.insert(name.clone(), val);
                    }
                    pc += 1;
                }
                Instruction::Add => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        stack.push(Value::Number(x + y));
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Sub => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        stack.push(Value::Number(x - y));
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Mul => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        stack.push(Value::Number(x * y));
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Div => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        if y == 0.0 {
                            stack.push(Value::Nil);
                        } else {
                            stack.push(Value::Number(x / y));
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Mod => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        if y == 0.0 {
                            stack.push(Value::Nil);
                        } else {
                            stack.push(Value::Number(x % y));
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::Concat => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = format!("{}{}", a, b);
                    stack.push(Value::String(result));
                    pc += 1;
                }
                Instruction::Equal => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    stack.push(Value::Boolean(a == b));
                    pc += 1;
                }
                Instruction::NotEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    stack.push(Value::Boolean(a != b));
                    pc += 1;
                }
                Instruction::LessThan => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x < y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    pc += 1;
                }
                Instruction::GreaterThan => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x > y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    pc += 1;
                }
                Instruction::LessEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x <= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    pc += 1;
                }
                Instruction::GreaterEqual => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    let result = if let (Value::Number(x), Value::Number(y)) = (&a, &b) {
                        x >= y
                    } else {
                        false
                    };
                    stack.push(Value::Boolean(result));
                    pc += 1;
                }
                Instruction::And => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    stack.push(Value::Boolean(a.is_truthy() && b.is_truthy()));
                    pc += 1;
                }
                Instruction::Or => {
                    let b = stack.pop().unwrap_or(Value::Nil);
                    let a = stack.pop().unwrap_or(Value::Nil);
                    stack.push(Value::Boolean(a.is_truthy() || b.is_truthy()));
                    pc += 1;
                }
                Instruction::Not => {
                    let a = stack.pop().unwrap_or(Value::Nil);
                    stack.push(Value::Boolean(!a.is_truthy()));
                    pc += 1;
                }
                Instruction::Jump(target) => {
                    pc = *target;
                }
                Instruction::JumpIfFalse(target) => {
                    let condition = stack.pop().unwrap_or(Value::Nil);
                    if !condition.is_truthy() {
                        pc = *target;
                    } else {
                        pc += 1;
                    }
                }
                Instruction::Print => {
                    if let Some(val) = stack.pop() {
                        println!("{}", val);
                    }
                    pc += 1;
                }
                Instruction::MakeTable(size) => {
                    let mut elements = Vec::new();
                    for _ in 0..*size {
                        if let Some(val) = stack.pop() {
                            elements.push(val);
                        }
                    }
                    elements.reverse();
                    stack.push(Value::Table(elements));
                    pc += 1;
                }
                Instruction::MakeDict(size) => {
                    let mut entries = HashMap::new();
                    for _ in 0..*size {
                        let value = stack.pop().unwrap_or(Value::Nil);
                        let key = match stack.pop().unwrap_or(Value::Nil) {
                            Value::String(s) => s,
                            v => v.to_string(),
                        };
                        entries.insert(key, value);
                    }
                    stack.push(Value::Dictionary(entries));
                    pc += 1;
                }
                Instruction::GetIndex => {
                    let index = stack.pop().unwrap_or(Value::Nil);
                    let table = stack.pop().unwrap_or(Value::Nil);

                    match (table, index) {
                        (Value::Table(elems), Value::Number(idx)) => {
                            let i = idx as usize;
                            if i < elems.len() {
                                stack.push(elems[i].clone());
                            } else {
                                stack.push(Value::Nil);
                            }
                        }
                        (Value::Dictionary(map), Value::String(key)) => {
                            stack.push(map.get(&key).cloned().unwrap_or(Value::Nil));
                        }
                        (Value::String(s), Value::Number(idx)) => {
                            let i = idx as usize;
                            if i < s.len() {
                                stack.push(Value::String(s.chars().nth(i).unwrap().to_string()));
                            } else {
                                stack.push(Value::Nil);
                            }
                        }
                        _ => stack.push(Value::Nil),
                    }
                    pc += 1;
                }
                Instruction::GetMember(name) => {
                    let obj = stack.pop().unwrap_or(Value::Nil);
                    match obj {
                        Value::Module(members) => {
                            stack.push(members.get(name).cloned().unwrap_or(Value::Nil));
                        }
                        Value::Dictionary(map) => {
                            stack.push(map.get(name).cloned().unwrap_or(Value::Nil));
                        }
                        _ => stack.push(Value::Nil),
                    }
                    pc += 1;
                }
                Instruction::Call(func_name, arg_count) => {
                    // Handle function calls within functions (including recursion)
                    if let Some(func_val) = vars.get(func_name).cloned() {
                        match func_val {
                            Value::Function(params, body) => {
                                if params.len() != *arg_count {
                                    eprintln!("Error: Function {} expects {} arguments, got {}", func_name, params.len(), arg_count);
                                    pc += 1;
                                    continue;
                                }

                                // Pop arguments from stack
                                let mut args = Vec::new();
                                for _ in 0..*arg_count {
                                    if let Some(arg) = stack.pop() {
                                        args.push(arg);
                                    }
                                }
                                args.reverse();

                                // Create local scope with parameters bound to arguments
                                let mut func_vars = vars.clone();
                                for (i, param_name) in params.iter().enumerate() {
                                    if i < args.len() {
                                        func_vars.insert(param_name.clone(), args[i].clone());
                                    }
                                }

                                // Execute function recursively
                                Self::execute_function(&body, stack, &mut func_vars, verbose);

                                // Return value is left on stack by the function
                            }
                            _ => {
                                eprintln!("Error: {} is not a function", func_name);
                                stack.push(Value::Nil);
                            }
                        }
                    } else {
                        eprintln!("Error: Function {} not found in function context", func_name);
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::CallMethod(members, arg_count) => {
                    let base = stack.pop().unwrap_or(Value::Nil);
                    let mut args = Vec::new();
                    for _ in 0..*arg_count {
                        if let Some(arg) = stack.pop() {
                            args.push(arg);
                        }
                    }
                    args.reverse();

                    let mut current = base;
                    let method_name = members.last().cloned().unwrap_or_default();

                    for i in 0..members.len() - 1 {
                        current = match current {
                            Value::Module(ref map) => map.get(&members[i]).cloned().unwrap_or(Value::Nil),
                            Value::Dictionary(ref map) => map.get(&members[i]).cloned().unwrap_or(Value::Nil),
                            _ => Value::Nil,
                        };
                    }

                    let method = match &current {
                        Value::Module(map) => map.get(&method_name).cloned(),
                        Value::Dictionary(map) => map.get(&method_name).cloned(),
                        _ => None,
                    };

                    if let Some(method_val) = method {
                        match method_val {
                            Value::NativeFunction(module, func) => {
                                let result = crate::stdlib::call_native(&module, &func, args, verbose);
                                stack.push(result);
                            }
                            Value::Function(params, body) => {
                                let mut func_vars = vars.clone();
                                for (i, param) in params.iter().enumerate() {
                                    if i < args.len() {
                                        func_vars.insert(param.clone(), args[i].clone());
                                    }
                                }
                                Self::execute_function(&body, stack, &mut func_vars, verbose);
                            }
                            _ => stack.push(Value::Nil),
                        }
                    } else {
                        stack.push(Value::Nil);
                    }
                    pc += 1;
                }
                Instruction::SetupTry(catch_pc) => {
                    try_handlers.push(TryHandler {
                        catch_pc: *catch_pc,
                        stack_depth: stack.len(),
                    });
                    pc += 1;
                }
                Instruction::PopTry => {
                    try_handlers.pop();
                    pc += 1;
                }
                Instruction::Throw => {
                    let error = stack.pop().unwrap_or(Value::String("Unknown error".to_string()));
                    if let Some(handler) = try_handlers.pop() {
                        while stack.len() > handler.stack_depth {
                            stack.pop();
                        }
                        stack.push(error);
                        pc = handler.catch_pc;
                    } else {
                        eprintln!("Uncaught error: {}", error);
                        break;
                    }
                }
                Instruction::Return => {
                    // Return from function - the value on top of stack is the return value
                    if verbose {
                        println!("  [Function] Return");
                    }
                    break;
                }
                _ => {
                    // For other instructions, just advance
                    pc += 1;
                }
            }
        }
    }
}
