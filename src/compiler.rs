use crate::ast::AstNode;
use std::collections::HashMap;

/// Bytecode instructions for the Pickup VM.
#[derive(Debug, Clone)]
pub enum Instruction {
    PushNumber(f64),
    PushString(String),
    PushBoolean(bool),
    LoadVar(String),
    StoreVar(String),
    Add,
    Sub,
    Mul,
    Div,
    Concat,
    Print,
    MakeTable(usize),  // Create a table with n elements from stack
    GetIndex,          // Get value at index from table
    LoadModule(String), // Load standard library module
}

/// Compile an AST to bytecode instructions.
pub struct Compiler;

impl Compiler {
    pub fn compile(ast: &AstNode, verbose: bool) -> Vec<Instruction> {
        let mut code = Vec::new();
        Self::compile_node(ast, &mut code);
        if verbose {
            println!("Generated bytecode: {:?}", code);
        }
        code
    }

    fn compile_node(node: &AstNode, code: &mut Vec<Instruction>) {
        match node {
            AstNode::Program(stmts) => {
                for stmt in stmts {
                    Self::compile_node(stmt, code);
                }
            }
            AstNode::Number(n) => code.push(Instruction::PushNumber(*n)),
            AstNode::String(s) => code.push(Instruction::PushString(s.clone())),
            AstNode::Boolean(b) => code.push(Instruction::PushBoolean(*b)),
            AstNode::Identifier(id) => code.push(Instruction::LoadVar(id.clone())),
            AstNode::Assignment(var, expr) => {
                // var is Identifier
                if let AstNode::Identifier(name) = &**var {
                    Self::compile_node(expr, code);
                    code.push(Instruction::StoreVar(name.clone()));
                }
            }
            AstNode::BinaryOp(left, op, right) => {
                Self::compile_node(left, code);
                Self::compile_node(right, code);
                match op.as_str() {
                    "+" => code.push(Instruction::Add),
                    "-" => code.push(Instruction::Sub),
                    "*" => code.push(Instruction::Mul),
                    "/" => code.push(Instruction::Div),
                    ".." => code.push(Instruction::Concat),
                    _ => {}
                }
            }
            AstNode::Print(expr) => {
                Self::compile_node(expr, code);
                code.push(Instruction::Print);
            }
            AstNode::Table(elements) => {
                for elem in elements {
                    Self::compile_node(elem, code);
                }
                code.push(Instruction::MakeTable(elements.len()));
            }
            AstNode::Index(base, index) => {
                Self::compile_node(base, code);
                Self::compile_node(index, code);
                code.push(Instruction::GetIndex);
            }
            AstNode::Import(module) => {
                code.push(Instruction::LoadModule(module.clone()));
            }
            _ => {}
        }
    }
}

/// Value types for the Pickup VM.
#[derive(Debug, Clone)]
pub enum Value {
    Number(f64),
    String(String),
    Boolean(bool),
    Table(Vec<Value>),
    Module(HashMap<String, Value>),
    Nil,
}

impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Value::Number(n) => write!(f, "{}", n),
            Value::String(s) => write!(f, "{}", s),
            Value::Boolean(b) => write!(f, "{}", b),
            Value::Table(elems) => {
                let items: Vec<String> = elems.iter().map(|v| v.to_string()).collect();
                write!(f, "[{}]", items.join(", "))
            }
            Value::Module(_) => write!(f, "<module>"),
            Value::Nil => write!(f, "nil"),
        }
    }
}

// Helper to convert string representation to Value
fn string_to_value(s: &str) -> Value {
    if let Ok(n) = s.parse::<f64>() {
        Value::Number(n)
    } else if s == "true" {
        Value::Boolean(true)
    } else if s == "false" {
        Value::Boolean(false)
    } else if s == "nil" {
        Value::Nil
    } else {
        Value::String(s.to_string())
    }
}

/// Simple bytecode interpreter.
pub struct Vm;

impl Vm {
    pub fn execute(code: &[Instruction], verbose: bool) {
        let mut stack: Vec<Value> = Vec::new();
        let mut vars: HashMap<String, Value> = HashMap::new();
        
        // Initialize standard library
        let stdlib = crate::stdlib::create_stdlib();

        if verbose {
            println!("\n--- VM Execution Log ---");
        }

        for (i, inst) in code.iter().enumerate() {
            if verbose {
                println!("Instruction {}: {:?}", i, inst);
            }

            match inst {
                Instruction::PushNumber(n) => {
                    stack.push(Value::Number(*n));
                    if verbose {
                        println!("  Pushed number {}", n);
                    }
                }
                Instruction::PushString(s) => {
                    stack.push(Value::String(s.clone()));
                    if verbose {
                        println!("  Pushed string \"{}\"", s);
                    }
                }
                Instruction::PushBoolean(b) => {
                    stack.push(Value::Boolean(*b));
                    if verbose {
                        println!("  Pushed boolean {}", b);
                    }
                }
                Instruction::LoadVar(name) => {
                    let val = vars.get(name).cloned().unwrap_or(Value::Nil);
                    stack.push(val.clone());
                    if verbose {
                        println!("  Loaded var {} = {:?}", name, val);
                    }
                }
                Instruction::StoreVar(name) => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Stored {:?} in var {}", val, name);
                        }
                        vars.insert(name.clone(), val);
                    }
                }
                Instruction::Add => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x + y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Add: {} + {} = {}", x, y, res);
                        }
                    }
                }
                Instruction::Sub => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x - y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Sub: {} - {} = {}", x, y, res);
                        }
                    }
                }
                Instruction::Mul => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x * y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Mul: {} * {} = {}", x, y, res);
                        }
                    }
                }
                Instruction::Div => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    if let (Value::Number(x), Value::Number(y)) = (a, b) {
                        let res = x / y;
                        stack.push(Value::Number(res));
                        if verbose {
                            println!("  Div: {} / {} = {}", x, y, res);
                        }
                    }
                }
                Instruction::Concat => {
                    let b = stack.pop().unwrap();
                    let a = stack.pop().unwrap();
                    let result = format!("{}{}", a, b);
                    stack.push(Value::String(result.clone()));
                    if verbose {
                        println!("  Concat: \"{}\" .. \"{}\" = \"{}\"", a, b, result);
                    }
                }
                Instruction::MakeTable(size) => {
                    let mut elements = Vec::new();
                    for _ in 0..*size {
                        if let Some(val) = stack.pop() {
                            elements.push(val);
                        }
                    }
                    elements.reverse();
                    stack.push(Value::Table(elements));
                    if verbose {
                        println!("  Created table with {} elements", size);
                    }
                }
                Instruction::GetIndex => {
                    let index = stack.pop().unwrap();
                    let table = stack.pop().unwrap();
                    
                    if let (Value::Table(elems), Value::Number(idx)) = (table, index) {
                        let i = idx as usize;
                        if i < elems.len() {
                            stack.push(elems[i].clone());
                            if verbose {
                                println!("  Got element at index {}", i);
                            }
                        } else {
                            stack.push(Value::Nil);
                            if verbose {
                                println!("  Index {} out of bounds", i);
                            }
                        }
                    }
                }
                Instruction::LoadModule(name) => {
                    if let Some(module) = stdlib.get(name) {
                        vars.insert(name.clone(), module.clone());
                        if verbose {
                            println!("  Loaded module {}", name);
                        }
                    } else {
                        eprintln!("Module '{}' not found", name);
                    }
                }
                Instruction::Print => {
                    if let Some(val) = stack.pop() {
                        if verbose {
                            println!("  Print: {:?}", val);
                            println!(">> {}", val);
                        } else {
                            println!("{}", val);
                        }
                    }
                }
            }

            if verbose {
                println!("  Stack: {:?}", stack);
                println!("  Vars: {:?}", vars);
                println!("");
            }
        }

        if verbose {
            println!("--- VM Execution Completed ---\n");
        }
    }
}
